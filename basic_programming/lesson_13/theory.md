# 00. Когда использовать equals
* Метод equals используется тогда, когда нужно сравнить два объекта
* Т.е. когда переменные, которые мы сравниваем, не примитивного типа
* Как определить примитивный тип? Все примитивные типы начинаются с маленькой буквы, 
тогда как пользовательски-определяемые, т.е. переменные которых являются объектами, начинаются с большой буквы
```
String s1 = "Hello";
String s2 = "Hello";

System.out.println(s1.equals(s2)); // сравниваем два объекта правильно
System.out.println(s2.equals(s1)); // тоже самое что и предыдущая строка
// Альтернатива
System.out.println(Objects.equals(s1, s2));
```

# 01. Алгоритм бинарного поиска (АБП)
* АБП - это оптимизированный алгоритм поиска, который будет находить индекс нужного элемента очень быстро
* Это значит что он будет работать намного быстрее линейного поиска
* Но есть одно НО - он работает только над сортированными данными
* Алгоритм работает таким образом:
1. Находит центр массива
2. Сравнивает элемент по центру с искомым. Если они совпадают, значит элемент найден, записываем индекс и прекращаем поиск
3. Если элемент по центру меньше искомого, это значит, что искомый элемент будет в правой части. 
В таком случае мы перемещаем нижнюю границу рассматриваемой части та место текущего центра.
4. Если же элемент по центру больше искомого, это значит, что искомый элемент будет в левой части.
В таком случае мы перемещаем верхнюю границу рассматриваемой части та место текущего центра.
5. Если верхняя граница стала меньше нижней, это значит, что мы закончили поиск.

Пример реализации АБП в Java
```
int[] arr = { 1, 4, 6, 9, 15 };

        int value = 9; // еще может называться ключом поиска (key)

        int low = 0;
        int high = arr.length - 1;
        int index = -1;
        // пока верхняя граница больше или равна нижней
        while (low <= high) {
            // рассчет индекса центрального элемента в рассматриваемой области массива
            int mid = low + ((high - low) / 2);
            
            if (arr[mid] == value) {
                // если элемент по центру равен искомому, записываем результат и прекращаем поиск
                index = mid;
                break;
            } else if (arr[mid] < value) {
                // если значение больше, двигаем нижнюю границу к центру + 1
                // +1 нужен чтобы исключить элемент по центру из следующей рассматриваемой области массива
                low = mid + 1;
            } else {
                // если значение меньше, двигаем верхнюю границу к центру - 1
                // -1 нужен чтобы исключить элемент по центру из следующей рассматриваемой области массива
                high = mid - 1;
            }
        }

        System.out.println(index);
```

* Такой алгоритм лучше всего писать с помощью рекурсивных методов, но такого мы еще не учили
* Вот примерная схема выполнения этой программы по итерациям, для сравнения приведен пример линейного поиска того ще элемента

![image](https://raw.githubusercontent.com/ait-tr/cohort36/main/basic_programming/lesson_13/img/1.png)

# 02. Ключевые слова и идентификаторы
* Ключевое слово - это такое слово, которое зарезервировано языком программирования для обозначения внутреннего функционала
* Является базовой частичкой синтаксиса языка
* Синтаксис языка Java состоит из операторов, ключевых слов, идентификаторов и литералов
* Идентификаторы - это просто уникальные названия переменных, классов, методов и т.д.
* Для именования идентификаторов нельзя использовать ключевые слова, не добавляя других символов
* В идентификаторах разрешается буквы верхнего и нижнего регистра, подчеркивания и цифры, при условии что цифра не первый символ
# 03. Практика
* Факториал любого натурального числа это произведение всех натуральных чисел, которые на числовой прямой идут до этого числа включительно
* Обозначается знаком !
* Пример:
```
5! = 1 * 2 * 3 * 4 * 5 = 120
7! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040
```
* Напоминание: После if, else, do, while и for пишется фигурная ВМЕСТО точки с запятой
* Лирическое отступление: The Twin Prime Conjecture - интересная гипотеза в математике (раздел теории чисел), которая предполагает, что
количество простых чисел-близнецов (т.е. таких, которые отличаются на 2) бесконечное количество.
* Эта гипотеза не была доказана, но вы можете попытаться написать программу, которая посчитает частоту появления (плотность)
таких чисел на отрезке числовой прямой длинной в 1000 чисел, а потом сравнить эти частоты для всех таких отрезков в границах значений int (Сложность: невыполнимо (11/10))
# Словарик
* input - ввод
* Prime number - простое число (то, которое делится нацело только на себя и 1)