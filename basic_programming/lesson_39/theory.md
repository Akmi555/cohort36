## 01. Переопределение методов
* В наследовании мы уже привыкли, что можем наследовать свойства. Но при этом, мы также наследуем и методы тоже!
* Но, в методах все немного труднее. Обычно, наследуемые поля изменять нельзя, а вот методы - можно!
* Изменение наследуемого метода называется переопределение.
* Пожалуйста, не путайте переопределение (overriding) и перегрузку (overloading).
* При этом, изменять можно только выполняемый блок кода.

* Для того чтобы переопределить метод, нужно его записать еще раз с аннотацией `@Override`
* Аннотация - дополняющая запись к методу, классу либо полю с дополнительной информацией для компилятора.
* Суперметод - логика та же, что и суперконструктор - это просто метод из родительского класса.
* В отличии от суперконструктора, суперметод не нужно вызывать первым. Его можно вызвать когда угодно.

## 01.5 Класс Object
* В Java существует такой класс Object. Этот класс будет неявно наследоваться абсолютно всеми классами в Java.
* Это сделано для того, чтобы мы могли иметь стандартный набор методов, которые можно переопределить в каждом классе.
* Самыми частыми методами которые прийдется переопределять будут:
  * toString - превращает текущий объект в строку. Для того чтобы было удобнее выводить этот 
  объект в консоль (либо куда-то еще).
  * equals - сравнивает текущий объект с переданным, и возвращает `true` если они равны.
  * hashCode - создает хэш объекта.


## 02. Восходящее и нисходящее преобразование
* Мы привыкли к тому, что числа можно переводить из одного типа в другой
```
int num = 5;
double dNum = (double) num; // преобразование типа
```
* Когда мы превращаем объект какого-то типа в объект дочернего типа, это называется нисходящее преобразование.
* Когда мы превращаем объект дочернего типа в объект родительского, это восходящее преобразование.

* При восходящем преобразовании, обычно в переменную более высокого класса иерархии (родительский) 
записывается объект более низкого класса (дочернего).
* При этом, все записанные данные объекта сохраняются и никуда не пропадают.
* Но, получить доступ к данным, которых нет в классе-типе переменной, в которой сохранен объект, невозможно.
* Иными словами, доступные для вызова методы будут определяться типом ссылки, а не объекта, который в ней записан.

* При нисходящем преобразовании, происходит примерно тоже самое как и при преобразовании примитивных типов.
* Но, простое преобразование как с примитивными типами может вести к ошибке выполнения ClassCastException.
Эта ошибка говорит о том, что мы пытались перевести объект какого-то класса в другой не связанный с ним класс.
* Чтобы этой ошибки избежать, перед преобразованием нужно делать проверку типа объекта
* Это делается с помощью ключевого слова `instanceof`
* instanceof будет возвращать true если по ссылке записан объект переданного класса.

* Если произошло восходящее преобразование и мы пытаемся вызвать метод из переменной, этот метод будет вызываться
из объекта.
* Это значит, что если этот метод переопреден в дочернем классе, то будет вызываться именно это переопределение.
