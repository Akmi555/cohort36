## 01. Внутренние классы, итераторы и цикл foreach
* Внутренний класс - это такой класс, который определен внутри другого класса. Внутренние классы могут быть статическими
```
public class Outer {
    /* Какой-то код внешнего класса */
    
    public static class Inner {
        /* Здесь код внутреннего классса */
    }
    
    /* Какой-то код внешнего класса */
}
...
// в меине:
Outer.Inner obj = new Outer.Inner();

// или, в секции импортов
import static Outer.Inner;

// в меине
Inner obj = new Inner();
```
* Итератор - это специальный класс, который задает правила итерирования (прохождения) по коллекции элементов
  (массив, список и тд)
* Он позволяет не только задавать определенные правила итерирования, но и делать, например, несколько способов 
пройтись по набору элементов (например, из конца в начало)
* Но, для одного класса рекомендуется делать только один итератор.
* Для того чтобы сделать итератор, класс сначала нужно пометить как Iterable.
* После этого, создаем внутренний класс, который будет реализовывать интерфейс Iterator.
* В этом классе реализовать два метода:
  * hasNext - возвращает истину, если остались элементы, которые можно прочитать
  * next - возвращает следующий элемент и передвигает итератор на один шаг вперед.
* Помимо этого, нужно также определить, как данные из колекции попадут в итератор.
Обычно это делается через конструктор, в который просто передается ссылка на сохраненные данные коллекции.

* Обратите внимание: Когда мы записываем угловые скобки во время наследования или реализации 
обобщенного класса или интерфейса, мы в угловых скобках используем уже существующий тип, а не создаем новый.

* Цикл for-each (для-каждого) позволяет упростить работу с коллекциями, убирая все лишние переменные и действия.
* Обратите внимание, что эти действия никуда не исчезают, они просто переносятся в итератор
* Этот цикл позволяет нам упростить и сделать работу с любой коллекцией одинаковой.
* В этом цикле нужно создать переменную, потом после двоеточия записать объект, класс которого реализует Iterable
* Читается это как "Для каждого объекта из коллекции (ваш объект) выполнять..."
* Эта часть где "выполнять..." это как раз таки тело цикла
* Другими словами, в примере
```
for (String s : greetings) {
    System.out.println(s + " world!");
}
```

String s будет новым объектом на каждой итерации, а сами значения будут предоставляться методом next
из написанного нами итератора

## 02. Односвязный список
* Список - это такая коллекция элементов, которая хранит эти элементы не подряд (как массив), а в связанных узлы.
* Списки бывают односвязными и двухсвязными, а еще цикличными и нецикличными.

![image](https://raw.githubusercontent.com/ait-tr/cohort36/main/basic_programming/lesson_11/img/1.png)

Все варианты связных списков

![image](https://raw.githubusercontent.com/ait-tr/cohort36/main/basic_programming/lesson_11/img/2.png)

Упрощенная схема двухсвязного цикличного списка

* Односвязные списки это такие, в которых каждый узел указывает на следующий узел, а последний элемент ни на что не указывает.
* В двусвязных списках, каждый узел указывает на предыдущий и следующий узел.
* Цикличный список отличается от нецикличного тем, что последний элемент также указывает на первый.

![image](https://raw.githubusercontent.com/ait-tr/cohort36/main/basic_programming/lesson_11/img/3.png)

Как в памяти хранится массив

![image](https://raw.githubusercontent.com/ait-tr/cohort36/main/basic_programming/lesson_11/img/4.png)

Как в памяти (может) храниться связный список

* Преимущества односвязного списка над массивом:
  * Не хранится подряд, поэтому можно сохранить много элементов даже если память почти заполнена.
  * Намного быстрее и эффективнее можно добавлять и удалять элементы списка.
  * Итерация происходит быстрее.
* Недостатки:
  * Не существует индексации. Получение элемента по индексу происходит дольше.
  * По этой же причине, нельзя сразу узнать размер. Узнать размер можно только пройдя по всем элементам.

